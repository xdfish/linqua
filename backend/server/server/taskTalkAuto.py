from typing import *
from task import Task, ObjectId
from speech import Speech, WordPresent, GrammarError
from pydantic import BaseModel
from words import Words
from datetime import datetime


class HitwordsUsed(BaseModel):
    word: str
    used: bool

class TaskTalkScore(BaseModel):
    length: int
    hitwods: int

class TaskTalkReport(BaseModel):
    text_recognized: str
    words_recognized: List[str]
    hitwords_used: List[WordPresent]
    grammar_errors: List[GrammarError]
    score: TaskTalkScore

class TalkAutoTaskInfo(BaseModel):
    taskid: str
    tmpid: str
    text: str
    hitwords: List[str]
    time_limit: int
    countdown: int
    word_count_min: int
    word_count_max: int
    word_count_best: int

    b64image: Optional[str] = None

class TalkAutoTask(Task):
    TASK_TYPE = 'TALK-AUTOGEN'

    def __init__(self, id: str) -> None:
        """Konstruktor zum Erzeugen einer Automatisch generierten Sprachaufgabe

        :param id: Aufgaben ID
        :type id: str
        """
        super().__init__(id)
        self.text = self._task_data['text']
        self.hitwords = self._task_data['hitwords']
        self.word_count_min = self._task_data['word_count_min']
        self.word_count_max = self._task_data['word_count_max']
        self.word_count_best = self._task_data['word_count_best']
        self.time_limit = self._task_data['time_limit']
        self.countdown = self._task_data['countdown']
        self.dynamic_hitwords = self._task_data['dynamic_hitwords']

    def solve(self, speech: Speech, tmpid: str):
        """Löst die Aufgabe (eingabe der Sprachdaten)

        :param speech: Srachdaten in Form einer Speech Klasse
        :type speech: Speech
        :return: Bewertung der Lösung
        :rtype: TaskTalkReport
        """
        self.solution: Speech = speech
        if not (tmp_data := self.tmp_storage_pop(tmpid)):
            raise Exception('no tmp data for autogenerated task')
        self.hitwords = tmp_data['words']
        self.hitwords_used = self.solution.has_words(self.hitwords)
        
        return TaskTalkReport(
            text_recognized = self.solution.text,
            words_recognized = self.solution.words,
            hitwords_used = self.hitwords_used,
            grammar_errors = self.solution.grammar,
            score = self.score
        )

    def generate(self, min_freq: float = 0, max_freq: float = 1) -> TalkAutoTaskInfo:
        """Startet den Prozess der Erzeigung einer automatisch generierten Aufgabe 

        :param min_freq: minimaler Wert der Häufigkeit der verwendeten wörter (Schwierigkeit untere Schranke), defaults to 0
        :type min_freq: float, optional
        :param max_freq: maximaler Wert der Häufigkeit der verwendeten wörter (Schwierigkeit obere Schranke), defaults to 1
        :type max_freq: float, optional
        :return: Informationen einer automatisch generierten Aufgabe
        :rtype: TalkAutoTaskInfo
        """
        wordsDB = Words()
        for dyn_word in self.dynamic_hitwords:
            self.hitwords += wordsDB.get(word_type=dyn_word['class'], amount=dyn_word['count'], min_freq=min_freq, max_freq=max_freq)
        tmpid = self.tmp_storage_save(self.hitwords)
        return TalkAutoTaskInfo(
            taskid = self.id,
            tmpid = tmpid,
            text = self.text,
            hitwords = self.hitwords,
            time_limit = self.time_limit,
            countdown = self.countdown,
            word_count_min = self.word_count_min,
            word_count_max = self.word_count_max,
            word_count_best = self.word_count_best,
        )

    def tmp_storage_save(self, words: List[str]) -> str:
        """Speichert die temporär verwendeten (automatisch generierten Worte) einer Aufgabe für die spätere Bewertung

        :param words: Liste mit verwendeten Wörtern
        :type words: List[str]
        :return: Datenbank ID der Wortliste
        :rtype: str
        """
        data  = dict(
            words = words,
            task_type = self.TASK_TYPE,
            created = datetime.now().strftime(Task.TIME_FORMAT)
        )
        return str(Task.tmp_storage.insert_one(data).inserted_id)

    def tmp_storage_pop(self, tmpid: str):
        """Entfernt die temporär abgelegten Wortliste der AUfgabe

        :param tmpid: Datenbank ID der temporären Daten
        :type tmpid: str
        :return: _description_
        :rtype: _type_
        """
        oid = ObjectId(tmpid)
        data = Task.tmp_storage.find_one({'_id': oid})
        Task.tmp_storage.delete_one({'_id': oid})
        return data

    @property
    def score(self) -> TaskTalkScore:
        """Liefert den Score der beweteten Aufgabe

        :return: Scoreobjekt der Aufgabe
        :rtype: TaskTalkScore
        """
        #HITWORDS
        hits = 0
        for used_word in self.hitwords_used:
            hits += 1 if used_word.present else 0
        score_hitword = int(100 * hits / len(self.hitwords))
        score_length = int(100 if self.solution.word_count > self.word_count_min else 100 * (self.solution.word_count/self.word_count_min))
        return TaskTalkScore(
            length=score_length,
            hitwods=score_hitword
        )

    @staticmethod
    def create(creator: str, text: str, hitwords: List[str], word_count_min: int, word_count_max: int, word_count_best: int, time_limit: int, countdown: int, dynamic_hitwords: List[Dict], **kwargs):
        """Erzeugt eine Aufgabe vom Type Sprechen (siehe Konstruktor) 

        :param creator: Erzeuger der Aufgabe
        :type creator: str
        :param text: Aufgabentext (stellung)
        :type text: str
        :param hitwords: List mit Hitwörtern die verwendet werden sollen
        :type hitwords: List[str]
        :param word_count_min: Minimale Anzahl an Wörtern (Bewertungm Punkte)
        :type word_count_min: Optional[int]
        :param word_count_max: Maximale Anzahl an Wörter (Bewertung, Abzug wenn überschritten)
        :type word_count_max: int
        :param word_count_best: Gute Anzahl an Wörtern (Bewertung, Bonuspunkte)
        :type word_count_best: Optional[int]
        :param time_limit: Zeitliches Limit (in Sekunden)
        :type time_limit: int
        :param countdown: Zeit des Countdowns
        :type countdown: int
        :param dynamic_hitwords: liste mit dynamischen Hitwords
        :type dynamic_hitwords: List[Dict]
        :return: Aufgabenobjekt
        :rtype: TalkAutoTask
        """
        return super(TalkAutoTask, TalkAutoTask).create(
            creator = creator,
            task_type = TalkAutoTask.TASK_TYPE,
            task_attribs = dict(
                text = text,
                hitwords = hitwords,
                word_count_min = word_count_min,
                word_count_max = word_count_max,
                word_count_best = word_count_best,
                time_limit = time_limit,
                countdown = countdown,
                dynamic_hitwords = dynamic_hitwords
            )
        )